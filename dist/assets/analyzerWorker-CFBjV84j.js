(function(){"use strict";/**
        @file Hexbuffer JS.

        @author Christian W. Zuckschwerdt <zany@triq.net>
        @copyright Christian W. Zuckschwerdt, 2020
        @license
        This program is free software: you can redistribute it and/or modify
        it under the terms of the GNU General Public License as published by
        the Free Software Foundation, either version 2 of the License, or
        (at your option) any later version.
    */function M(u,s=2){return(u+65536).toString(16).substr(-s).toUpperCase()}class B{constructor(s=""){this.fromString(s)}fromString(s){this.line=s.replace(/\s/g,""),this.index=0}hasNibble(){return this.index+1<=this.line.length}hasByte(){return this.index+2<=this.line.length}hasWord(){return this.index+4<=this.line.length}peekNibble(){return parseInt(this.line.substr(this.index,1),16)}peekByte(){return parseInt(this.line.substr(this.index,2),16)}peekWord(){return parseInt(this.line.substr(this.index,4),16)}getNibble(){const s=parseInt(this.line.substr(this.index,1),16);return this.index+=1,s}getByte(){const s=parseInt(this.line.substr(this.index,2),16);return this.index+=2,s}getWord(){const s=parseInt(this.line.substr(this.index,4),16);return this.index+=4,s}pushNibble(s){this.line+=M(s,1)}pushByte(s){this.line+=M(s,2)}pushWord(s){this.line+=M(s,4)}}/**
        @file Histogram JS.

        @author Christian W. Zuckschwerdt <zany@triq.net>
        @copyright Christian W. Zuckschwerdt, 2020
        @license
        This program is free software: you can redistribute it and/or modify
        it under the terms of the GNU General Public License as published by
        the Free Software Foundation, either version 2 of the License, or
        (at your option) any later version.
    */const P=16;class ${constructor(s){typeof s<"u"?(this.count=1,this.sum=s,this.mean=s,this.devi=0,this.min=s,this.max=s):(this.count=0,this.sum=0,this.mean=null,this.devi=0,this.min=null,this.max=null)}add(s){this.count++,this.sum+=s,this.mean=this.sum/this.count,this.min=this.min===null?s:Math.min(s,this.min),this.max=this.max===null?s:Math.max(s,this.max),this.devi=(this.max-this.min)/2}fuse(s){this.count+=s.count,this.sum+=s.sum,this.mean=this.sum/this.count,this.min=Math.min(this.min,s.min),this.max=Math.max(this.max,s.max),this.devi=(this.max-this.min)/2}contains(s){return s>=this.min&&s<=this.max}}class w{constructor(s,t=.2){this.bins=[],this.histogram_sum(s,t)}get length(){return this.bins.length}histogram_sum(s,t=.2){const n=s.length;for(let e=0;e<n;++e){let i;for(i=0;i<this.bins.length;++i){const h=s[e],l=this.bins[i].mean;if(Math.abs(h-l)<t*Math.max(h,l)){this.bins[i].add(s[e]);break}}i==this.bins.length&&i<P&&this.bins.push(new $(s[e]))}}delete_bin(s){this.bins.splice(s,1)}swap_bins(s,t){if(s<this.bins.length&&t<this.bins.length){const n=this.bins[s];this.bins[s]=this.bins[t],this.bins[t]=n}}sort_mean(){if(!(this.bins.length<2))for(let s=0;s<this.bins.length-1;++s)for(let t=s+1;t<this.bins.length;++t)this.bins[t].mean<this.bins[s].mean&&this.swap_bins(t,s)}sort_count(){if(!(this.bins.length<2))for(let s=0;s<this.bins.length-1;++s)for(let t=s+1;t<this.bins.length;++t)this.bins[t].count<this.bins[s].count&&this.swap_bins(t,s)}fuse_bins(s=.2){if(!(this.bins.length<2))for(let t=0;t<this.bins.length-1;++t)for(let n=t+1;n<this.bins.length;++n){const e=this.bins[t].mean,i=this.bins[n].mean;Math.abs(e-i)<s*Math.max(e,i)&&(this.bins[t].fuse(this.bins[n]),this.delete_bin(n),n--)}}trim_bins(s=0){for(let t=0;t<this.bins.length;++t)this.bins[t].mean<=s&&this.delete_bin(t)}find_bin_index(s){for(let t=0;t<this.bins.length;++t)if(this.bins[t].contains(s))return t;return-1}console_print(){for(let s=0;s<this.bins.length;++s){const t=this.bins[s];console.log(`[${s}] ${t.count} × ${t.mean.toFixed(1)} ±${t.devi.toFixed(1)} µs [${t.min};${t.max}]`)}}string_print(s=", "){let t=[];for(let n=0;n<this.bins.length;++n){const e=this.bins[n];t.push(`${e.count}× ${e.mean.toFixed(1)} <small>±${e.devi.toFixed(1)}</small> µs`)}return t.join(s)}}class O{constructor(s,t=.2){this.analyse_pulses(s,t),this.create_rfraw(s)}analyse_pulses(s,t,n=.2){this.pulses=[],this.gaps=[],this.periods=[],this.pulse_sum=0,this.gap_sum=0;for(let i=0;i<s.length-2;i+=2){const h=s[i],l=s[i+1];this.pulses.push(h),this.gaps.push(l),this.periods.push(h+l),this.pulse_sum+=h,this.gap_sum+=l}const e=s[s.length-2];this.pulses.push(e),this.pulse_sum+=e,this.pulse_gap_ratio=this.pulse_sum/this.gap_sum,this.pulse_gap_skew=this.pulse_gap_ratio-1,this.hist_pulses=new w(this.pulses,n),this.hist_gaps=new w(this.gaps,n),this.hist_periods=new w(this.periods,n),this.hist_timings=new w(s,n),this.hist_pulses.trim_bins(n),this.hist_gaps.trim_bins(n),this.hist_periods.trim_bins(n),this.hist_timings.trim_bins(n),this.hist_pulses.fuse_bins(n),this.hist_gaps.fuse_bins(n),this.hist_periods.fuse_bins(n),this.hist_timings.fuse_bins(n)}guess(){const s=this.hist_pulses,t=this.hist_gaps,n=this.hist_periods;if(s.sort_mean(),t.sort_mean(),s.bins.length>0&&s.bins[0].mean==0&&s.delete_bin(0),this.pulses.length==1)return{name:"Single pulse detected. Probably Frequency Shift Keying or just noise..."};if(s.length==1&&t.length==1)return{name:"Un-modulated signal. Maybe a preamble..."};if(s.length==1&&t.length>1)return{name:"Pulse Position Modulation with fixed pulse width",modulation:"PPM",short:t.bins[0].mean,long:t.bins[1].mean,gap:t.bins[1].max*1.2,reset:t.bins[t.length-1].max*1.2};if(s.length==2&&t.length==1){const e=s.bins[0].mean,i=s.bins[1].mean;return{name:"Pulse Width Modulation with fixed gap",modulation:"PWM",short:e,long:i,tolerance:(i-e)*.4,reset:t.bins[t.length-1].max*1.2}}else if(s.length==2&&t.length==2&&n.length==1){const e=s.bins[0].mean,i=s.bins[1].mean;return{name:"Pulse Width Modulation with fixed period",modulation:"PWM",short:e,long:i,tolerance:(i-e)*.4,reset:t.bins[t.length-1].max*1.2}}else if(s.length==2&&t.length==2&&n.length==3){const e=s.bins[0].mean;return{name:"Manchester coding (PCM)",modulation:"MC",short:e,long:e,reset:t.bins[t.length-1].max*1.2}}else if(s.length==2&&t.length>=3){const e=s.bins[0].mean,i=s.bins[1].mean;return{name:"Pulse Width Modulation with multiple packets",modulation:"PWM",short:e,long:i,gap:t.bins[1].max*1.2,tolerance:(i-e)*.4,reset:t.bins[t.length-1].max*1.2}}else{if(s.length>=3&&t.length>=3&&Math.abs(s.bins[1].mean-2*s.bins[0].mean)<=s.bins[0].mean/8&&Math.abs(s.bins[2].mean-3*s.bins[0].mean)<=s.bins[0].mean/8&&Math.abs(t.bins[0].mean-s.bins[0].mean)<=s.bins[0].mean/8&&Math.abs(t.bins[1].mean-2*s.bins[0].mean)<=s.bins[0].mean/8&&Math.abs(t.bins[2].mean-3*s.bins[0].mean)<=s.bins[0].mean/8)return{name:"Pulse Code Modulation (Not Return to Zero)",modulation:"PCM",short:s.bins[0].mean,long:s.bins[0].mean,reset:s.bins[0].mean*1024};if(s.length==3){s.sort_count();const e=s.bins[1].mean,i=s.bins[2].mean,h=e<i?e:i,l=e<i?i:e;return{name:"Pulse Width Modulation with sync/delimiter",modulation:"PWM",short:h,long:l,sync:s.bins[0].mean,reset:t.bins[t.length-1].max*1.2}}else return{name:"No clue..."}}}create_rfraw(s){const t=this.hist_timings;if(t.bins.length<1||t.bins.length>8||s.length>494)return"";let n=new B;for(let h of t.bins)n.pushWord(h.mean);for(let h=0;h<s.length-1;h+=2){const l=s[h],o=s[h+1],r=t.find_bin_index(l);r>=0?n.pushNibble(r|8):l==0||console.error("RfRaw encoding mark bucket not found:",l,r);const p=t.find_bin_index(o);p>=0?n.pushNibble(p):o==0||console.error("RfRaw encoding space bucket not found:",o,p)}n.line.length%2&&n.pushNibble(0),n.pushByte(85);let e=new B;e.pushByte(170),e.pushByte(176),e.pushByte(2+n.line.length/2-1),e.pushByte(t.bins.length),e.pushByte(1);let i=new B;i.pushByte(170),i.pushByte(177),i.pushByte(t.bins.length),this.rfrawB0=e.line+n.line,this.rfrawB1=i.line+n.line}console_log(){const s=this.guess();console.log("Analyzing pulses..."),console.log(`Total count: ${this.pulses.length}`),console.log("Pulse width distribution:"),this.hist_pulses.console_print(),console.log("Gap width distribution:"),this.hist_gaps.console_print(),console.log("Pulse period distribution:"),this.hist_periods.console_print(),console.log("Pulse timing distribution:"),this.hist_timings.console_print(),console.log(`DC bias (Pulse/Gap skew): ${(this.pulse_gap_skew*100).toFixed(1)}`),console.log("Guessing modulation:"),console.log(s)}print_plain(s){const t=this.guess();s.innerHTML=`
        <div>Pulses: ${this.hist_pulses.string_print()}</div>
        <div>Gaps: ${this.hist_gaps.string_print()}</div>
        <div>Periods: ${this.hist_periods.string_print()}</div>
        <div>Timings: ${this.hist_timings.string_print()}</div>
        <div>${t.name}</div>
        `}print(s,t){const n=this.guess();s&&(s.innerHTML=`<table>
            <tr><th>Pulses</th><td>${this.hist_pulses.string_print("</td><td>")}</td></tr>
            <tr><th>Gaps</th><td>${this.hist_gaps.string_print("</td><td>")}</td></tr>
            <tr><th>Periods</th><td>${this.hist_periods.string_print("</td><td>")}</td></tr>
            <tr><th>Timings</th><td>${this.hist_timings.string_print("</td><td>")}</td></tr>
            </table>
            `),t&&(t.innerHTML=`
            <div><small>DC bias (Pulse/Gap skew): ${(this.pulse_gap_skew*100).toFixed(1)}%</small><br>
            Guessing modulation: <strong>${n.name}</strong><br>
            modulation: <strong>${n.modulation}</strong>
            short: <strong>${n.short?n.short.toFixed(1):"-"}</strong>
            long: <strong>${n.long?n.long.toFixed(1):"-"}</strong>
            sync: <strong>${n.sync?n.sync.toFixed(1):"-"}</strong>
            gap: <strong>${n.gap?n.gap.toFixed(1):"-"}</strong>
            reset: <strong>${n.reset?n.reset.toFixed(1):"-"}</strong><br>
            <small>RfRaw (rx): <strong>${this.rfrawB1?this.rfrawB1:"-"}</strong></small><br>
            <small>RfRaw (tx): <strong>${this.rfrawB0?this.rfrawB0:"-"}</strong></small>
            </div>
            `)}}/**
        @file Bitbuffer JS.

        @author Christian W. Zuckschwerdt <zany@triq.net>
        @copyright Christian W. Zuckschwerdt, 2020
        @license
        This program is free software: you can redistribute it and/or modify
        it under the terms of the GNU General Public License as published by
        the Free Software Foundation, either version 2 of the License, or
        (at your option) any later version.
    */class _{constructor(s=[],t=0){Array.isArray(s)?(this.bytes=s,this.len=t||s.length*8):this.fromString(s)}fromString(s){this.bytes=[],this.len=0;let t=-1;if(s=s.trim(),s.startsWith("{")){const n=s.indexOf("}");if(n<0)return;t=parseInt(s.slice(1),10),s=s.slice(n+1)}s.startsWith("0x")&&(s=s.slice(2));for(let n of s){const e=parseInt(n,16);this.pushNibble(e)}t>=0&&(this.len=t)}pushZero(){this.push(0)}pushOne(){this.push(1)}pushSymbol(s){s=="0"?this.push(0):s=="1"&&this.push(1)}push(s){s=s?128:0,this.bytes[~~(this.len/8)]|=s>>this.len%8,this.len+=1}pushNibble(s){for(let t=3;t>=0;--t)this.push(s>>t&1)}pushByte(s){for(let t=7;t>=0;--t)this.push(s>>t&1)}pushBreak(){const s=~~((this.len+7)/8);this.bytes[s]=-1,this.len=(s+1)*8}toBitArray(){let s=[];for(let t=0;t<this.len;++t){const e=(this.bytes[~~(t/8)]||0)>>7-t%8&1;s.push(e)}return s}toHexString(){let s=`{${this.len}}`;for(let t=0;t<this.len;t+=8){const n=this.bytes[~~(t/8)]||0;n<0?s+=" / ":(s+=" ",s+=(n>>4).toString(16).toUpperCase(),t+4<this.len&&(s+=(n&15).toString(16).toUpperCase()))}return s}}/**
        @file Pulse Slicer JS.

        @author Christian W. Zuckschwerdt <zany@triq.net>
        @copyright Christian W. Zuckschwerdt, 2020
        @license
        This program is free software: you can redistribute it and/or modify
        it under the terms of the GNU General Public License as published by
        the Free Software Foundation, either version 2 of the License, or
        (at your option) any later version.
    */function Z(u,s){return s.modulation=="PCM"?W(u,s):s.modulation=="MC"?N(u,s):s.modulation=="PPM"?C(u,s):s.modulation=="PWM"?I(u,s):s.modulation=="DM"?R(u,s):s.modulation=="NRZI"?S(u,s):s.modulation=="CMI"?F(u,s):s.modulation=="PIWM"?G(u,s):[]}function W(u,s){return!s.long||s.long==s.short?j(u,s):v(u,s)}function j(u,s){const t=s.short,n=s.gap,e=new _;let i=[],h=0;for(let l=0;l<u.length;l+=1){const o=1-l%2,r=u[l];if(n&&r>n)e.pushBreak();else{const p=~~(r/t+.5);for(let a=0;a<p;++a)i.push([h+r/p*a,h+r/p*(a+1),o]),e.push(o)}h+=r}return{hints:i,bits:e}}function v(u,s){const t=s.short,n=s.long,e=s.gap,i=t*.5,h=t*1.5,l=new _;let o=[],r=0;for(let p=0;p<u.length;p+=2){const a=u[p],c=u[p+1];if(a<i||a>h){l.pushBreak(),r+=a+c;continue}let m=a*n/t,f=c+a-m;if(f<n/2&&(m=a+c,f=0),o.push([r,r+m,"1"]),l.pushOne(),r+=m,e&&c>e){l.pushBreak(),r+=f;continue}const b=~~(f/n+.5);for(let g=0;g<b;++g)o.push([r+f*g/b,r+f*(g+1)/b,"0"]),l.pushZero();r+=f}return{hints:o,bits:l}}function C(u,s){const t=s.short,n=s.long,e=s.sync,i=s.gap,h=t*.5,l=t*1.5,o=n*.5,r=n*1.5,p=e*.5,a=e*1.5,c=new _;let m=[],f=0;for(let b=0;b<u.length;b+=2){const g=u[b],d=u[b+1],x=f;f+=g+d,d>h&&d<l?(m.push([x,f,"1"]),c.pushOne()):d>o&&d<r?(m.push([x,f,"0"]),c.pushZero()):d>p&&d<a?(m.push([x,f,"X"]),c.pushBreak()):i&&d>i&&c.pushBreak()}return{hints:m,bits:c}}function I(u,s){const t=s.short,n=s.long,e=s.sync,i=s.gap,h=t*.5,l=t*1.5,o=n*.5,r=n*1.5,p=e*.5,a=e*1.5,c=new _;let m=[],f=0;for(let b=0;b<u.length;b+=2){const g=u[b],d=u[b+1],x=f;let y=f+g+d;d>i&&(y=f+g+i),f+=g+d,g>h&&g<l?(m.push([x,y,"1"]),c.pushOne()):g>o&&g<r?(m.push([x,y,"0"]),c.pushZero()):g>p&&g<a&&(m.push([x,y,"X"]),c.pushBreak()),i&&d>i&&c.pushBreak()}return{hints:m,bits:c}}function k(u,s,t){for(let n=s;n<u.length;n+=2){if(~~(u[n]/t+.5)>1)return 0;if(~~(u[n+1]/t+.5)>1)return 1}return 0}function N(u,s){const t=s.short,n=new _;let e=[],i=k(u,0,t),h=0,l=0;for(let o=0;o<u.length;o+=2){const r=u[o],p=~~(r/t+.5),a=u[o+1],c=~~(a/t+.5);p==1?(i?l=h:(e.push([l,h+r,"0"]),n.pushZero(),l=h+r),i=!i):p==2?(i?(n.pushBreak(),l=h+r/2):(e.push([l,h+r/2,"0"]),n.pushZero(),l=h+r/2),i=!1):p>2&&(i||(e.push([l,h+r/p,"0"]),n.pushZero()),l=h+r-r/p,n.pushBreak(),i=k(u,o+1,t)),c==1?(i?l=h+r:(e.push([l,h+r+a,"1"]),n.pushOne(),l=h+r+a),i=!i):c==2?(i?(n.pushBreak(),l=h+r+a/2):(e.push([l,h+r+a/2,"1"]),n.pushOne(),l=h+r+a/2),i=!1):c>2&&(i||(e.push([l,h+r+a/c,"1"]),n.pushOne()),l=h+r+a-a/c,n.pushBreak(),i=k(u,o+1,t)),h+=r+a}return{hints:e,bits:n}}function R(u,s){const t=s.short,n=new _;let e=[],i=0,h=null;for(let l=0;l<u.length;l+=2){const o=u[l],r=~~(o/t+.5),p=u[l+1],a=~~(p/t+.5);!h&&r==1&&a==1?(e.push([i,i+o+p,"0"]),n.pushZero()):r==1&&a==1?(e.push([h,i+o,"0"]),n.pushZero(),h=i+o):h&&r==1&&a==2?(e.push([h,i+o,"0"]),n.pushZero(),e.push([i+o,i+o+p,"1"]),n.pushOne(),h=null):r==2&&a==1?(e.push([i,i+o,"1"]),n.pushOne(),h=i+o):r==2&&a==2?(e.push([i,i+o,"1"]),n.pushOne(),e.push([i+o,i+o+p,"1"]),n.pushOne()):!h&&r==1?(e.push([i,i+o+t,"0"]),n.pushZero(),n.pushBreak()):!h&&r==2?(e.push([i,i+o,"1"]),n.pushOne(),n.pushBreak()):(h&&(e.push([h,h+t*2,"0"]),n.pushZero()),h=null,n.pushBreak()),i+=o+p}return{hints:e,bits:n}}function S(u,s){const t=s.short,n=new _;let e=[],i=0,h=0;for(let l=0;l<u.length;l+=1){const o=u[l],r=~~(o/t+.5);h&&(e.push([h,i+t/2,"1"]),n.pushOne()),h=i+t/2;for(let p=1;p<r;++p)e.push([h,h+o/r,"0"]),n.pushZero(),h+=o/r;i+=o}return{hints:e,bits:n}}function F(u,s){const t=s.short,n=new _;let e=[],i=0,h=null;for(let l=0;l<u.length;l+=2){const o=u[l],r=~~(o/t+.5),p=u[l+1],a=~~(p/t+.5);r==1&&a==1?(h||(h=i-o),e.push([h,i+o,"0"]),n.pushZero(),h=i+o):r==1&&a==2?(h||(h=i-o),e.push([h,i+o,"0"]),n.pushZero(),h=i+o+p,e.push([i+o,h,"1"]),n.pushOne()):r==1&&a==3?(h||(h=i-o),e.push([h,i+o,"0"]),n.pushZero(),h=i+o+p*2/3,e.push([i+o,h,"1"]),n.pushOne()):r==2&&a==1?(e.push([h,i+o,"1"]),n.pushOne(),h=i+o):r==2&&a==2?(e.push([h,i+o,"1"]),n.pushOne(),h=i+o+p,e.push([i+o,h,"1"]),n.pushOne()):r==2&&a==3?(e.push([h,i+o,"1"]),n.pushOne(),h=i+o+p*2/3,e.push([i+o,h,"1"]),n.pushOne()):r==3&&a==1?(e.push([h,i+o/3,"0"]),n.pushZero(),e.push([i+o/3,i+o,"1"]),n.pushOne(),h=i+o):r==3&&a==2?(e.push([h,i+o/3,"0"]),n.pushZero(),e.push([i+o/3,i+o,"1"]),n.pushOne(),h=i+o+p,e.push([i+o,h,"1"]),n.pushOne()):r==3&&a==3?(e.push([h,i+o/3,"0"]),n.pushZero(),e.push([i,i+o/3,"1"]),n.pushOne(),e.push([i+o/3,i+o,"1"]),n.pushOne(),e.push([i+o,i+o+p*3/2,"1"]),n.pushOne(),h=i+o+p*3/2):r==1?(e.push([h,i+o,"0"]),n.pushZero(),n.pushBreak(),h=i+o):r==2?(e.push([h,i+o,"1"]),n.pushOne(),n.pushBreak(),h=i+o):n.pushBreak(),i+=o+p}return{hints:e,bits:n}}function G(u,s){const t=s.short,n=new _;let e=[],i=0;for(let h=0;h<u.length;h+=1){const l=u[h],o=~~(l/t+.5);o==1?(e.push([i,i+l,"1"]),n.pushOne()):o==2?(e.push([i,i+l,"0"]),n.pushZero()):n.pushBreak(),i+=l}return{hints:e,bits:n}}onmessage=async function(u){var h;const{pulses:s,pickedSlicer:t}=u.data,n=new O(s),e=n.guess();e.modulation=t||e.modulation;const i=Z(s,e);i.hex=(h=i.bits)==null?void 0:h.toHexString(),this.setTimeout(()=>{},1e3),postMessage({analyzer:n,guessed:e,sg:i})}})();
